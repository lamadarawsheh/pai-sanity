{"_id": "challenge-two-sum", "_type": "codingChallenge", "title": "Two Sum", "slug": {"_type": "slug", "current": "two-sum"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 15, "category": "Arrays", "tags": ["arrays", "hash-table", "beginner"], "acceptanceRate": 49, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 1, "description": [{"_type": "block", "_key": "d1", "children": [{"_type": "span", "text": "Given an array of integers "},{"_type": "span", "text": "nums", "marks": ["code"]},{"_type": "span", "text": " and an integer "},{"_type": "span", "text": "target", "marks": ["code"]},{"_type": "span", "text": ", return indices of the two numbers such that they add up to target."}]},{"_type": "block", "_key": "d2", "children": [{"_type": "span", "text": "You may assume that each input would have exactly one solution, and you may not use the same element twice."}]},{"_type": "block", "_key": "d3", "style": "h4", "children": [{"_type": "span", "text": "Example 1:"}]},{"_type": "block", "_key": "d4", "children": [{"_type": "span", "text": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1]."}]},{"_type": "block", "_key": "d5", "style": "h4", "children": [{"_type": "span", "text": "Example 2:"}]},{"_type": "block", "_key": "d6", "children": [{"_type": "span", "text": "Input: nums = [3,2,4], target = 6\nOutput: [1,2]"}]},{"_type": "block", "_key": "d7", "style": "h4", "children": [{"_type": "span", "text": "Constraints:"}]},{"_type": "block", "_key": "d8", "children": [{"_type": "span", "text": "• 2 <= nums.length <= 10⁴\n• -10⁹ <= nums[i] <= 10⁹\n• -10⁹ <= target <= 10⁹\n• Only one valid answer exists."}]}], "hints": ["Think about what you need to find: two numbers that add up to target", "A hash map can help you find complements in O(1) time", "For each number, check if (target - number) exists in your hash map"], "starterCode": [{"language": "python", "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find two numbers that add up to target.\n    \n    Args:\n        nums: List of integers\n        target: Target sum\n    \n    Returns:\n        Indices of the two numbers\n    \"\"\"\n    # Your code here\n    pass"}, {"language": "javascript", "code": "/**\n * Find two numbers that add up to target.\n * @param {number[]} nums - Array of integers\n * @param {number} target - Target sum\n * @return {number[]} - Indices of the two numbers\n */\nfunction twoSum(nums, target) {\n    // Your code here\n}"}], "testCases": [{"input": "[2, 7, 11, 15], 9", "expectedOutput": "[0, 1]", "isHidden": false}, {"input": "[3, 2, 4], 6", "expectedOutput": "[1, 2]", "isHidden": false}, {"input": "[3, 3], 6", "expectedOutput": "[0, 1]", "isHidden": false}, {"input": "[1, 5, 8, 3, 9, 2], 11", "expectedOutput": "[2, 3]", "isHidden": true}, {"input": "[-1, -2, -3, -4, -5], -8", "expectedOutput": "[2, 4]", "isHidden": true}], "solution": [{"language": "python", "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}  # value -> index\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"}, {"language": "javascript", "code": "function twoSum(nums, target) {\n    const seen = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (seen.has(complement)) {\n            return [seen.get(complement), i];\n        }\n        seen.set(nums[i], i);\n    }\n    return [];\n}"}]}
{"_id": "challenge-reverse-linked-list", "_type": "codingChallenge", "title": "Reverse Linked List", "slug": {"_type": "slug", "current": "reverse-linked-list"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 20, "category": "Linked Lists", "tags": ["linked-list", "recursion", "pointers"], "acceptanceRate": 72, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 2, "description": [{"_type": "block", "_key": "d1", "children": [{"_type": "span", "text": "Given the "},{"_type": "span", "text": "head", "marks": ["code"]},{"_type": "span", "text": " of a singly linked list, reverse the list, and return the reversed list."}]},{"_type": "block", "_key": "d2", "style": "h4", "children": [{"_type": "span", "text": "Example 1:"}]},{"_type": "block", "_key": "d3", "children": [{"_type": "span", "text": "Input: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]"}]},{"_type": "block", "_key": "d4", "style": "h4", "children": [{"_type": "span", "text": "Example 2:"}]},{"_type": "block", "_key": "d5", "children": [{"_type": "span", "text": "Input: head = [1,2]\nOutput: [2,1]"}]},{"_type": "block", "_key": "d6", "style": "h4", "children": [{"_type": "span", "text": "Constraints:"}]},{"_type": "block", "_key": "d7", "children": [{"_type": "span", "text": "• The number of nodes is in range [0, 5000]\n• -5000 <= Node.val <= 5000"}]},{"_type": "block", "_key": "d8", "style": "h4", "children": [{"_type": "span", "text": "Follow up:"}]},{"_type": "block", "_key": "d9", "children": [{"_type": "span", "text": "Can you solve it both iteratively and recursively?"}]}], "hints": ["Keep track of three pointers: previous, current, and next", "Before changing the next pointer, store the next node", "Move all pointers one step forward", "For recursion: reverse the rest, then fix the head"], "starterCode": [{"language": "python", "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head: ListNode) -> ListNode:\n    \"\"\"\n    Reverse a singly linked list.\n    \n    Args:\n        head: Head of the linked list\n    \n    Returns:\n        Head of the reversed list\n    \"\"\"\n    # Your code here\n    pass"}, {"language": "javascript", "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * Reverse a singly linked list.\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction reverseList(head) {\n    // Your code here\n}"}], "testCases": [{"input": "[1, 2, 3, 4, 5]", "expectedOutput": "[5, 4, 3, 2, 1]", "isHidden": false}, {"input": "[1, 2]", "expectedOutput": "[2, 1]", "isHidden": false}, {"input": "[]", "expectedOutput": "[]", "isHidden": false}, {"input": "[1]", "expectedOutput": "[1]", "isHidden": true}, {"input": "[1, 2, 3]", "expectedOutput": "[3, 2, 1]", "isHidden": true}], "solution": [{"language": "python", "code": "# Iterative Solution\ndef reverse_list(head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n    while curr:\n        next_temp = curr.next  # Store next\n        curr.next = prev       # Reverse pointer\n        prev = curr            # Move prev forward\n        curr = next_temp       # Move curr forward\n    return prev\n\n# Recursive Solution\ndef reverse_list_recursive(head: ListNode) -> ListNode:\n    if not head or not head.next:\n        return head\n    new_head = reverse_list_recursive(head.next)\n    head.next.next = head\n    head.next = None\n    return new_head"}, {"language": "javascript", "code": "// Iterative Solution\nfunction reverseList(head) {\n    let prev = null;\n    let curr = head;\n    while (curr) {\n        const next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\n\n// Recursive Solution\nfunction reverseListRecursive(head) {\n    if (!head || !head.next) return head;\n    const newHead = reverseListRecursive(head.next);\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n}"}]}
{"_id": "challenge-valid-parentheses", "_type": "codingChallenge", "title": "Valid Parentheses", "slug": {"_type": "slug", "current": "valid-parentheses"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 15, "category": "Stack", "tags": ["stack", "string", "matching"], "acceptanceRate": 40, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 3, "description": [{"_type": "block", "_key": "d1", "children": [{"_type": "span", "text": "Given a string "},{"_type": "span", "text": "s", "marks": ["code"]},{"_type": "span", "text": " containing just the characters "},{"_type": "span", "text": "'('", "marks": ["code"]},{"_type": "span", "text": ", "},{"_type": "span", "text": "')'", "marks": ["code"]},{"_type": "span", "text": ", "},{"_type": "span", "text": "'{'", "marks": ["code"]},{"_type": "span", "text": ", "},{"_type": "span", "text": "'}'", "marks": ["code"]},{"_type": "span", "text": ", "},{"_type": "span", "text": "'['", "marks": ["code"]},{"_type": "span", "text": " and "},{"_type": "span", "text": "']'", "marks": ["code"]},{"_type": "span", "text": ", determine if the input string is valid."}]},{"_type": "block", "_key": "d2", "children": [{"_type": "span", "text": "An input string is valid if:"}]},{"_type": "block", "_key": "d3", "children": [{"_type": "span", "text": "1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type."}]},{"_type": "block", "_key": "d4", "style": "h4", "children": [{"_type": "span", "text": "Examples:"}]},{"_type": "block", "_key": "d5", "children": [{"_type": "span", "text": "Input: s = \"()\" → Output: true\nInput: s = \"()[]{}\" → Output: true\nInput: s = \"(]\" → Output: false\nInput: s = \"([)]\" → Output: false"}]},{"_type": "block", "_key": "d6", "style": "h4", "children": [{"_type": "span", "text": "Constraints:"}]},{"_type": "block", "_key": "d7", "children": [{"_type": "span", "text": "• 1 <= s.length <= 10⁴\n• s consists of parentheses only '()[]{}'"}]}], "hints": ["Use a stack to keep track of opening brackets", "When you see a closing bracket, check if it matches the top of stack", "At the end, the stack should be empty for a valid string", "Use a hash map to match brackets efficiently"], "starterCode": [{"language": "python", "code": "def is_valid(s: str) -> bool:\n    \"\"\"\n    Check if brackets in string are valid.\n    \n    Args:\n        s: String containing brackets\n    \n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    # Your code here\n    pass"}, {"language": "javascript", "code": "/**\n * Check if brackets in string are valid.\n * @param {string} s - String containing brackets\n * @return {boolean} - True if valid\n */\nfunction isValid(s) {\n    // Your code here\n}"}], "testCases": [{"input": "\"()\"", "expectedOutput": "true", "isHidden": false}, {"input": "\"()[]{}\"", "expectedOutput": "true", "isHidden": false}, {"input": "\"(]\"", "expectedOutput": "false", "isHidden": false}, {"input": "\"([)]\"", "expectedOutput": "false", "isHidden": false}, {"input": "\"{[]}\"", "expectedOutput": "true", "isHidden": false}, {"input": "\"(((())))\"", "expectedOutput": "true", "isHidden": true}, {"input": "\"]{\"", "expectedOutput": "false", "isHidden": true}], "solution": [{"language": "python", "code": "def is_valid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:  # Closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:  # Opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0"}, {"language": "javascript", "code": "function isValid(s) {\n    const stack = [];\n    const mapping = { ')': '(', '}': '{', ']': '[' };\n    \n    for (const char of s) {\n        if (mapping[char]) {\n            if (!stack.length || stack.pop() !== mapping[char]) {\n                return false;\n            }\n        } else {\n            stack.push(char);\n        }\n    }\n    \n    return stack.length === 0;\n}"}]}
{"_id": "challenge-maximum-subarray", "_type": "codingChallenge", "title": "Maximum Subarray", "slug": {"_type": "slug", "current": "maximum-subarray"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 25, "category": "Dynamic Programming", "tags": ["dp", "arrays", "kadane"], "acceptanceRate": 50, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 4, "description": [{"_type": "block", "_key": "d1", "children": [{"_type": "span", "text": "Given an integer array "},{"_type": "span", "text": "nums", "marks": ["code"]},{"_type": "span", "text": ", find the subarray with the largest sum, and return its sum."}]},{"_type": "block", "_key": "d2", "children": [{"_type": "span", "text": "A subarray is a contiguous non-empty sequence of elements within an array."}]},{"_type": "block", "_key": "d3", "style": "h4", "children": [{"_type": "span", "text": "Example 1:"}]},{"_type": "block", "_key": "d4", "children": [{"_type": "span", "text": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6."}]},{"_type": "block", "_key": "d5", "style": "h4", "children": [{"_type": "span", "text": "Example 2:"}]},{"_type": "block", "_key": "d6", "children": [{"_type": "span", "text": "Input: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23."}]},{"_type": "block", "_key": "d7", "style": "h4", "children": [{"_type": "span", "text": "Constraints:"}]},{"_type": "block", "_key": "d8", "children": [{"_type": "span", "text": "• 1 <= nums.length <= 10⁵\n• -10⁴ <= nums[i] <= 10⁴"}]},{"_type": "block", "_key": "d9", "style": "h4", "children": [{"_type": "span", "text": "Follow up:"}]},{"_type": "block", "_key": "d10", "children": [{"_type": "span", "text": "Can you solve it with O(n) time complexity using Kadane's algorithm?"}]}], "hints": ["Think about Kadane's algorithm", "At each position, decide: start a new subarray or extend the previous one?", "Keep track of both current sum and maximum sum seen so far", "If current sum becomes negative, reset it to 0"], "starterCode": [{"language": "python", "code": "def max_subarray(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum subarray sum.\n    \n    Args:\n        nums: List of integers\n    \n    Returns:\n        Maximum subarray sum\n    \"\"\"\n    # Your code here\n    pass"}, {"language": "javascript", "code": "/**\n * Find the maximum subarray sum.\n * @param {number[]} nums - Array of integers\n * @return {number} - Maximum subarray sum\n */\nfunction maxSubArray(nums) {\n    // Your code here\n}"}], "testCases": [{"input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]", "expectedOutput": "6", "isHidden": false}, {"input": "[1]", "expectedOutput": "1", "isHidden": false}, {"input": "[5, 4, -1, 7, 8]", "expectedOutput": "23", "isHidden": false}, {"input": "[-1]", "expectedOutput": "-1", "isHidden": true}, {"input": "[-2, -1]", "expectedOutput": "-1", "isHidden": true}, {"input": "[1, 2, 3, 4, 5]", "expectedOutput": "15", "isHidden": true}], "solution": [{"language": "python", "code": "def max_subarray(nums: list[int]) -> int:\n    # Kadane's Algorithm\n    max_sum = curr_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Either extend previous subarray or start fresh\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum"}, {"language": "javascript", "code": "function maxSubArray(nums) {\n    let maxSum = nums[0];\n    let currSum = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        currSum = Math.max(nums[i], currSum + nums[i]);\n        maxSum = Math.max(maxSum, currSum);\n    }\n    \n    return maxSum;\n}"}]}
{"_id": "challenge-binary-tree-level-order", "_type": "codingChallenge", "title": "Binary Tree Level Order Traversal", "slug": {"_type": "slug", "current": "binary-tree-level-order"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 30, "category": "Trees", "tags": ["trees", "bfs", "queue"], "acceptanceRate": 62, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 5, "description": [{"_type": "block", "_key": "d1", "children": [{"_type": "span", "text": "Given the "},{"_type": "span", "text": "root", "marks": ["code"]},{"_type": "span", "text": " of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level)."}]},{"_type": "block", "_key": "d2", "style": "h4", "children": [{"_type": "span", "text": "Example 1:"}]},{"_type": "block", "_key": "d3", "children": [{"_type": "span", "text": "Input: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]"}]},{"_type": "block", "_key": "d4", "style": "h4", "children": [{"_type": "span", "text": "Example 2:"}]},{"_type": "block", "_key": "d5", "children": [{"_type": "span", "text": "Input: root = [1]\nOutput: [[1]]"}]},{"_type": "block", "_key": "d6", "style": "h4", "children": [{"_type": "span", "text": "Constraints:"}]},{"_type": "block", "_key": "d7", "children": [{"_type": "span", "text": "• Number of nodes: [0, 2000]\n• -1000 <= Node.val <= 1000"}]}], "hints": ["Use BFS with a queue", "Process all nodes at current level before moving to next", "Track the number of nodes at each level", "Use deque for efficient popleft operation"], "starterCode": [{"language": "python", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef level_order(root: TreeNode) -> list[list[int]]:\n    \"\"\"\n    Return level order traversal of binary tree.\n    \n    Args:\n        root: Root of the binary tree\n    \n    Returns:\n        List of lists, each containing node values at that level\n    \"\"\"\n    # Your code here\n    pass"}, {"language": "javascript", "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * Return level order traversal.\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction levelOrder(root) {\n    // Your code here\n}"}], "testCases": [{"input": "[3, 9, 20, null, null, 15, 7]", "expectedOutput": "[[3], [9, 20], [15, 7]]", "isHidden": false}, {"input": "[1]", "expectedOutput": "[[1]]", "isHidden": false}, {"input": "[]", "expectedOutput": "[]", "isHidden": false}, {"input": "[1, 2, 3, 4, 5]", "expectedOutput": "[[1], [2, 3], [4, 5]]", "isHidden": true}], "solution": [{"language": "python", "code": "from collections import deque\n\ndef level_order(root: TreeNode) -> list[list[int]]:\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level = []\n        level_size = len(queue)\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result"}, {"language": "javascript", "code": "function levelOrder(root) {\n    if (!root) return [];\n    \n    const result = [];\n    const queue = [root];\n    \n    while (queue.length) {\n        const level = [];\n        const levelSize = queue.length;\n        \n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            level.push(node.val);\n            \n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        \n        result.push(level);\n    }\n    \n    return result;\n}"}]}


