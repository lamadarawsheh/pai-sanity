{"_id": "challenge-two-sum", "_type": "codingChallenge", "title": "Two Sum", "slug": {"_type": "slug", "current": "two-sum"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 15, "category": "Arrays", "tags": ["arrays", "hash-table", "beginner"], "acceptanceRate": 49, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 1, "hints": ["Think about what you need to find: two numbers that add up to target", "A hash map can help you find complements in O(1) time", "For each number, check if (target - number) exists in your hash map"], "starterCode": [{"language": "python", "code": "def two_sum(nums, target):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function twoSum(nums, target) {\n    // Your code here\n}"}], "testCases": [{"input": "[2, 7, 11, 15], 9", "expectedOutput": "[0, 1]", "isHidden": false}, {"input": "[3, 2, 4], 6", "expectedOutput": "[1, 2]", "isHidden": false}, {"input": "[3, 3], 6", "expectedOutput": "[0, 1]", "isHidden": true}], "solution": [{"language": "python", "code": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"}]}
{"_id": "challenge-reverse-linked-list", "_type": "codingChallenge", "title": "Reverse Linked List", "slug": {"_type": "slug", "current": "reverse-linked-list"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 20, "category": "Linked Lists", "tags": ["linked-list", "recursion", "pointers"], "acceptanceRate": 72, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 2, "hints": ["Keep track of three pointers: previous, current, and next", "Before changing the next pointer, store the next node", "Move all pointers one step forward"], "starterCode": [{"language": "python", "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function reverseList(head) {\n    // Your code here\n}"}], "testCases": [{"input": "[1, 2, 3, 4, 5]", "expectedOutput": "[5, 4, 3, 2, 1]", "isHidden": false}, {"input": "[1, 2]", "expectedOutput": "[2, 1]", "isHidden": false}, {"input": "[]", "expectedOutput": "[]", "isHidden": true}], "solution": [{"language": "python", "code": "def reverse_list(head):\n    prev = None\n    curr = head\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    return prev"}]}
{"_id": "challenge-valid-parentheses", "_type": "codingChallenge", "title": "Valid Parentheses", "slug": {"_type": "slug", "current": "valid-parentheses"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 15, "category": "Stack", "tags": ["stack", "string", "matching"], "acceptanceRate": 40, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 3, "hints": ["Use a stack to keep track of opening brackets", "When you see a closing bracket, check if it matches the top of stack", "At the end, the stack should be empty"], "starterCode": [{"language": "python", "code": "def is_valid(s):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function isValid(s) {\n    // Your code here\n}"}], "testCases": [{"input": "\"()\"", "expectedOutput": "true", "isHidden": false}, {"input": "\"()[]{}\"", "expectedOutput": "true", "isHidden": false}, {"input": "\"(]\"", "expectedOutput": "false", "isHidden": false}, {"input": "\"([)]\"", "expectedOutput": "false", "isHidden": true}], "solution": [{"language": "python", "code": "def is_valid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return len(stack) == 0"}]}
{"_id": "challenge-maximum-subarray", "_type": "codingChallenge", "title": "Maximum Subarray", "slug": {"_type": "slug", "current": "maximum-subarray"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 25, "category": "Dynamic Programming", "tags": ["dp", "arrays", "kadane"], "acceptanceRate": 50, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 4, "hints": ["Think about Kadane's algorithm", "At each position, decide: start fresh or extend the previous subarray?", "Keep track of both current sum and maximum sum seen"], "starterCode": [{"language": "python", "code": "def max_subarray(nums):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function maxSubArray(nums) {\n    // Your code here\n}"}], "testCases": [{"input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]", "expectedOutput": "6", "isHidden": false}, {"input": "[1]", "expectedOutput": "1", "isHidden": false}, {"input": "[5, 4, -1, 7, 8]", "expectedOutput": "23", "isHidden": true}], "solution": [{"language": "python", "code": "def max_subarray(nums):\n    max_sum = curr_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum"}]}
{"_id": "challenge-binary-tree-level-order", "_type": "codingChallenge", "title": "Binary Tree Level Order Traversal", "slug": {"_type": "slug", "current": "binary-tree-level-order"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 30, "category": "Trees", "tags": ["trees", "bfs", "queue"], "acceptanceRate": 62, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 5, "hints": ["Use BFS (Breadth-First Search) with a queue", "Process all nodes at current level before moving to next", "Track the number of nodes at each level"], "starterCode": [{"language": "python", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef level_order(root):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function levelOrder(root) {\n    // Your code here\n}"}], "testCases": [{"input": "[3, 9, 20, null, null, 15, 7]", "expectedOutput": "[[3], [9, 20], [15, 7]]", "isHidden": false}, {"input": "[1]", "expectedOutput": "[[1]]", "isHidden": false}], "solution": [{"language": "python", "code": "from collections import deque\n\ndef level_order(root):\n    if not root:\n        return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    return result"}]}
{"_id": "challenge-lru-cache", "_type": "codingChallenge", "title": "LRU Cache", "slug": {"_type": "slug", "current": "lru-cache"}, "difficulty": "hard", "xpReward": 80, "timeEstimate": 45, "category": "Hash Table", "tags": ["design", "hash-table", "linked-list", "cache"], "acceptanceRate": 40, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 6, "hints": ["Use a hash map for O(1) lookup", "Use a doubly linked list for O(1) insertion/deletion", "OrderedDict in Python combines both!"], "starterCode": [{"language": "python", "code": "class LRUCache:\n    def __init__(self, capacity):\n        # Your code here\n        pass\n    \n    def get(self, key):\n        # Your code here\n        pass\n    \n    def put(self, key, value):\n        # Your code here\n        pass"}, {"language": "javascript", "code": "class LRUCache {\n    constructor(capacity) {\n        // Your code here\n    }\n    \n    get(key) {\n        // Your code here\n    }\n    \n    put(key, value) {\n        // Your code here\n    }\n}"}], "testCases": [{"input": "LRUCache(2), put(1,1), put(2,2), get(1), put(3,3), get(2)", "expectedOutput": "1, -1", "isHidden": false}], "solution": [{"language": "python", "code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)"}]}
{"_id": "challenge-trapping-rain-water", "_type": "codingChallenge", "title": "Trapping Rain Water", "slug": {"_type": "slug", "current": "trapping-rain-water"}, "difficulty": "hard", "xpReward": 80, "timeEstimate": 40, "category": "Two Pointers", "tags": ["two-pointers", "dp", "stack", "arrays"], "acceptanceRate": 58, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 7, "hints": ["Water at each position = min(max_left, max_right) - height", "Two pointer approach: move the pointer with smaller max", "Track left_max and right_max as you go"], "starterCode": [{"language": "python", "code": "def trap(height):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function trap(height) {\n    // Your code here\n}"}], "testCases": [{"input": "[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]", "expectedOutput": "6", "isHidden": false}, {"input": "[4, 2, 0, 3, 2, 5]", "expectedOutput": "9", "isHidden": false}], "solution": [{"language": "python", "code": "def trap(height):\n    if not height:\n        return 0\n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    return water"}]}
{"_id": "challenge-merge-intervals", "_type": "codingChallenge", "title": "Merge Intervals", "slug": {"_type": "slug", "current": "merge-intervals"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 25, "category": "Arrays", "tags": ["arrays", "sorting", "intervals"], "acceptanceRate": 46, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 8, "hints": ["Sort intervals by start time first", "Merge if current interval overlaps with previous", "Update end time to max of both ends"], "starterCode": [{"language": "python", "code": "def merge(intervals):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function merge(intervals) {\n    // Your code here\n}"}], "testCases": [{"input": "[[1,3], [2,6], [8,10], [15,18]]", "expectedOutput": "[[1,6], [8,10], [15,18]]", "isHidden": false}, {"input": "[[1,4], [4,5]]", "expectedOutput": "[[1,5]]", "isHidden": false}], "solution": [{"language": "python", "code": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    for interval in intervals:\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return merged"}]}
{"_id": "lesson-intro-to-arrays", "_type": "lesson", "title": "Introduction to Arrays", "slug": {"_type": "slug", "current": "intro-to-arrays"}, "order": 1, "type": "concept", "xpReward": 50, "estimatedMinutes": 10}
{"_id": "lesson-array-operations", "_type": "lesson", "title": "Array Operations", "slug": {"_type": "slug", "current": "array-operations"}, "order": 2, "type": "concept", "xpReward": 50, "estimatedMinutes": 15}
{"_id": "lesson-two-sum-practice", "_type": "lesson", "title": "Two Sum Practice", "slug": {"_type": "slug", "current": "two-sum-practice"}, "order": 3, "type": "exercise", "xpReward": 75, "estimatedMinutes": 20, "challenge": {"_type": "reference", "_ref": "challenge-two-sum"}}
{"_id": "lesson-arrays-quiz", "_type": "lesson", "title": "Arrays Quiz", "slug": {"_type": "slug", "current": "arrays-quiz"}, "order": 4, "type": "quiz", "xpReward": 30, "estimatedMinutes": 10, "quiz": [{"question": "What is the time complexity of accessing an element by index in an array?", "options": ["O(1)", "O(n)", "O(log n)", "O(nÂ²)"], "correctIndex": 0, "explanation": "Arrays provide constant-time access by index because elements are stored contiguously in memory."}, {"question": "What happens when you append to a dynamic array that is full?", "options": ["Error is thrown", "The array doubles in size", "The element is not added", "The first element is removed"], "correctIndex": 1, "explanation": "Dynamic arrays typically double their capacity when full, resulting in amortized O(1) append."}]}
{"_id": "lesson-intro-to-linked-lists", "_type": "lesson", "title": "Introduction to Linked Lists", "slug": {"_type": "slug", "current": "intro-to-linked-lists"}, "order": 1, "type": "concept", "xpReward": 50, "estimatedMinutes": 15}
{"_id": "lesson-linked-list-operations", "_type": "lesson", "title": "Linked List Operations", "slug": {"_type": "slug", "current": "linked-list-operations"}, "order": 2, "type": "concept", "xpReward": 50, "estimatedMinutes": 15}
{"_id": "lesson-reverse-list-challenge", "_type": "lesson", "title": "Reverse Linked List Challenge", "slug": {"_type": "slug", "current": "reverse-list-challenge"}, "order": 3, "type": "challenge", "xpReward": 100, "estimatedMinutes": 25, "challenge": {"_type": "reference", "_ref": "challenge-reverse-linked-list"}}
{"_id": "lesson-intro-to-stacks", "_type": "lesson", "title": "Introduction to Stacks", "slug": {"_type": "slug", "current": "intro-to-stacks"}, "order": 1, "type": "concept", "xpReward": 50, "estimatedMinutes": 10}
{"_id": "lesson-stack-operations", "_type": "lesson", "title": "Stack Operations & Use Cases", "slug": {"_type": "slug", "current": "stack-operations"}, "order": 2, "type": "concept", "xpReward": 50, "estimatedMinutes": 15}
{"_id": "lesson-valid-parentheses-practice", "_type": "lesson", "title": "Valid Parentheses Practice", "slug": {"_type": "slug", "current": "valid-parentheses-practice"}, "order": 3, "type": "exercise", "xpReward": 75, "estimatedMinutes": 20, "challenge": {"_type": "reference", "_ref": "challenge-valid-parentheses"}}
{"_id": "lesson-intro-to-trees", "_type": "lesson", "title": "Introduction to Trees", "slug": {"_type": "slug", "current": "intro-to-trees"}, "order": 1, "type": "concept", "xpReward": 60, "estimatedMinutes": 20}
{"_id": "lesson-tree-traversals", "_type": "lesson", "title": "Tree Traversals", "slug": {"_type": "slug", "current": "tree-traversals"}, "order": 2, "type": "concept", "xpReward": 60, "estimatedMinutes": 20}
{"_id": "lesson-level-order-challenge", "_type": "lesson", "title": "Level Order Traversal Challenge", "slug": {"_type": "slug", "current": "level-order-challenge"}, "order": 3, "type": "challenge", "xpReward": 100, "estimatedMinutes": 30, "challenge": {"_type": "reference", "_ref": "challenge-binary-tree-level-order"}}
{"_id": "chapter-arrays-basics", "_type": "chapter", "title": "Arrays Fundamentals", "description": "Learn the basics of arrays - the most fundamental data structure in programming.", "order": 1, "xpReward": 200, "lessons": [{"_type": "reference", "_ref": "lesson-intro-to-arrays"}, {"_type": "reference", "_ref": "lesson-array-operations"}, {"_type": "reference", "_ref": "lesson-two-sum-practice"}, {"_type": "reference", "_ref": "lesson-arrays-quiz"}]}
{"_id": "chapter-linked-lists", "_type": "chapter", "title": "Linked Lists", "description": "Master linked lists - understand pointers, nodes, and list manipulation.", "order": 2, "xpReward": 200, "lessons": [{"_type": "reference", "_ref": "lesson-intro-to-linked-lists"}, {"_type": "reference", "_ref": "lesson-linked-list-operations"}, {"_type": "reference", "_ref": "lesson-reverse-list-challenge"}]}
{"_id": "chapter-stacks-queues", "_type": "chapter", "title": "Stacks & Queues", "description": "Learn LIFO and FIFO data structures and their applications.", "order": 3, "xpReward": 175, "lessons": [{"_type": "reference", "_ref": "lesson-intro-to-stacks"}, {"_type": "reference", "_ref": "lesson-stack-operations"}, {"_type": "reference", "_ref": "lesson-valid-parentheses-practice"}]}
{"_id": "chapter-trees", "_type": "chapter", "title": "Trees & Graphs", "description": "Explore hierarchical data structures and traversal algorithms.", "order": 4, "xpReward": 220, "lessons": [{"_type": "reference", "_ref": "lesson-intro-to-trees"}, {"_type": "reference", "_ref": "lesson-tree-traversals"}, {"_type": "reference", "_ref": "lesson-level-order-challenge"}]}
{"_id": "path-data-structures-mastery", "_type": "learningPath", "title": "Data Structures Mastery", "slug": {"_type": "slug", "current": "data-structures-mastery"}, "description": "Master the fundamental data structures every developer needs to know. From arrays to trees, build a solid foundation for technical interviews.", "icon": "account_tree", "color": "from-cyan-500 to-teal-500", "difficulty": "medium", "totalXp": 795, "estimatedHours": 8, "order": 1, "enrolledCount": 0, "completedCount": 0, "prerequisites": ["Basic programming knowledge", "Familiarity with any programming language"], "chapters": [{"_type": "reference", "_ref": "chapter-arrays-basics"}, {"_type": "reference", "_ref": "chapter-linked-lists"}, {"_type": "reference", "_ref": "chapter-stacks-queues"}, {"_type": "reference", "_ref": "chapter-trees"}]}
{"_id": "path-algorithm-fundamentals", "_type": "learningPath", "title": "Algorithm Fundamentals", "slug": {"_type": "slug", "current": "algorithm-fundamentals"}, "description": "Learn essential algorithms including sorting, searching, and problem-solving patterns used in technical interviews.", "icon": "functions", "color": "from-purple-500 to-pink-500", "difficulty": "medium", "totalXp": 600, "estimatedHours": 10, "order": 2, "enrolledCount": 0, "completedCount": 0, "prerequisites": ["Data Structures Mastery or equivalent knowledge"], "chapters": []}
{"_id": "path-dynamic-programming", "_type": "learningPath", "title": "Dynamic Programming", "slug": {"_type": "slug", "current": "dynamic-programming"}, "description": "Conquer the most challenging interview topic. Learn to recognize DP patterns and solve complex optimization problems.", "icon": "grid_on", "color": "from-orange-500 to-red-500", "difficulty": "hard", "totalXp": 1200, "estimatedHours": 15, "order": 3, "enrolledCount": 0, "completedCount": 0, "prerequisites": ["Algorithm Fundamentals", "Recursion knowledge"], "chapters": []}


