{"_id": "challenge-two-sum", "_type": "codingChallenge", "title": "Two Sum", "slug": {"_type": "slug", "current": "two-sum"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 15, "category": "Arrays", "tags": ["arrays", "hash-table", "beginner"], "acceptanceRate": 49, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 1, "hints": ["Think about what you need to find: two numbers that add up to target", "A hash map can help you find complements in O(1) time", "For each number, check if (target - number) exists in your hash map"], "starterCode": [{"language": "python", "code": "def two_sum(nums, target):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function twoSum(nums, target) {\n    // Your code here\n}"}], "testCases": [{"input": "[2, 7, 11, 15], 9", "expectedOutput": "[0, 1]", "isHidden": false}, {"input": "[3, 2, 4], 6", "expectedOutput": "[1, 2]", "isHidden": false}, {"input": "[3, 3], 6", "expectedOutput": "[0, 1]", "isHidden": true}], "solution": [{"language": "python", "code": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"}]}
{"_id": "challenge-reverse-linked-list", "_type": "codingChallenge", "title": "Reverse Linked List", "slug": {"_type": "slug", "current": "reverse-linked-list"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 20, "category": "Linked Lists", "tags": ["linked-list", "recursion", "pointers"], "acceptanceRate": 72, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 2, "hints": ["Keep track of three pointers: previous, current, and next", "Before changing the next pointer, store the next node", "Move all pointers one step forward"], "starterCode": [{"language": "python", "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function reverseList(head) {\n    // Your code here\n}"}], "testCases": [{"input": "[1, 2, 3, 4, 5]", "expectedOutput": "[5, 4, 3, 2, 1]", "isHidden": false}, {"input": "[1, 2]", "expectedOutput": "[2, 1]", "isHidden": false}, {"input": "[]", "expectedOutput": "[]", "isHidden": true}], "solution": [{"language": "python", "code": "def reverse_list(head):\n    prev = None\n    curr = head\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    return prev"}]}
{"_id": "challenge-valid-parentheses", "_type": "codingChallenge", "title": "Valid Parentheses", "slug": {"_type": "slug", "current": "valid-parentheses"}, "difficulty": "easy", "xpReward": 20, "timeEstimate": 15, "category": "Stack", "tags": ["stack", "string", "matching"], "acceptanceRate": 40, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 3, "hints": ["Use a stack to keep track of opening brackets", "When you see a closing bracket, check if it matches the top of stack", "At the end, the stack should be empty"], "starterCode": [{"language": "python", "code": "def is_valid(s):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function isValid(s) {\n    // Your code here\n}"}], "testCases": [{"input": "\"()\"", "expectedOutput": "true", "isHidden": false}, {"input": "\"()[]{}\"", "expectedOutput": "true", "isHidden": false}, {"input": "\"(]\"", "expectedOutput": "false", "isHidden": false}, {"input": "\"([)]\"", "expectedOutput": "false", "isHidden": true}], "solution": [{"language": "python", "code": "def is_valid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return len(stack) == 0"}]}
{"_id": "challenge-maximum-subarray", "_type": "codingChallenge", "title": "Maximum Subarray", "slug": {"_type": "slug", "current": "maximum-subarray"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 25, "category": "Dynamic Programming", "tags": ["dp", "arrays", "kadane"], "acceptanceRate": 50, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 4, "hints": ["Think about Kadane's algorithm", "At each position, decide: start fresh or extend the previous subarray?", "Keep track of both current sum and maximum sum seen"], "starterCode": [{"language": "python", "code": "def max_subarray(nums):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function maxSubArray(nums) {\n    // Your code here\n}"}], "testCases": [{"input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]", "expectedOutput": "6", "isHidden": false}, {"input": "[1]", "expectedOutput": "1", "isHidden": false}, {"input": "[5, 4, -1, 7, 8]", "expectedOutput": "23", "isHidden": true}], "solution": [{"language": "python", "code": "def max_subarray(nums):\n    max_sum = curr_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum"}]}
{"_id": "challenge-binary-tree-level-order", "_type": "codingChallenge", "title": "Binary Tree Level Order Traversal", "slug": {"_type": "slug", "current": "binary-tree-level-order"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 30, "category": "Trees", "tags": ["trees", "bfs", "queue"], "acceptanceRate": 62, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 5, "hints": ["Use BFS (Breadth-First Search) with a queue", "Process all nodes at current level before moving to next", "Track the number of nodes at each level"], "starterCode": [{"language": "python", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef level_order(root):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function levelOrder(root) {\n    // Your code here\n}"}], "testCases": [{"input": "[3, 9, 20, null, null, 15, 7]", "expectedOutput": "[[3], [9, 20], [15, 7]]", "isHidden": false}, {"input": "[1]", "expectedOutput": "[[1]]", "isHidden": false}], "solution": [{"language": "python", "code": "from collections import deque\n\ndef level_order(root):\n    if not root:\n        return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    return result"}]}
{"_id": "challenge-lru-cache", "_type": "codingChallenge", "title": "LRU Cache", "slug": {"_type": "slug", "current": "lru-cache"}, "difficulty": "hard", "xpReward": 80, "timeEstimate": 45, "category": "Hash Table", "tags": ["design", "hash-table", "linked-list", "cache"], "acceptanceRate": 40, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": true, "order": 6, "hints": ["Use a hash map for O(1) lookup", "Use a doubly linked list for O(1) insertion/deletion", "OrderedDict in Python combines both!"], "starterCode": [{"language": "python", "code": "class LRUCache:\n    def __init__(self, capacity):\n        # Your code here\n        pass\n    \n    def get(self, key):\n        # Your code here\n        pass\n    \n    def put(self, key, value):\n        # Your code here\n        pass"}, {"language": "javascript", "code": "class LRUCache {\n    constructor(capacity) {\n        // Your code here\n    }\n    \n    get(key) {\n        // Your code here\n    }\n    \n    put(key, value) {\n        // Your code here\n    }\n}"}], "testCases": [{"input": "LRUCache(2), put(1,1), put(2,2), get(1), put(3,3), get(2)", "expectedOutput": "1, -1", "isHidden": false}], "solution": [{"language": "python", "code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)"}]}
{"_id": "challenge-trapping-rain-water", "_type": "codingChallenge", "title": "Trapping Rain Water", "slug": {"_type": "slug", "current": "trapping-rain-water"}, "difficulty": "hard", "xpReward": 80, "timeEstimate": 40, "category": "Two Pointers", "tags": ["two-pointers", "dp", "stack", "arrays"], "acceptanceRate": 58, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 7, "hints": ["Water at each position = min(max_left, max_right) - height", "Two pointer approach: move the pointer with smaller max", "Track left_max and right_max as you go"], "starterCode": [{"language": "python", "code": "def trap(height):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function trap(height) {\n    // Your code here\n}"}], "testCases": [{"input": "[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]", "expectedOutput": "6", "isHidden": false}, {"input": "[4, 2, 0, 3, 2, 5]", "expectedOutput": "9", "isHidden": false}], "solution": [{"language": "python", "code": "def trap(height):\n    if not height:\n        return 0\n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    return water"}]}
{"_id": "challenge-merge-intervals", "_type": "codingChallenge", "title": "Merge Intervals", "slug": {"_type": "slug", "current": "merge-intervals"}, "difficulty": "medium", "xpReward": 40, "timeEstimate": 25, "category": "Arrays", "tags": ["arrays", "sorting", "intervals"], "acceptanceRate": 46, "totalSubmissions": 0, "totalSolved": 0, "isBossChallenge": false, "order": 8, "hints": ["Sort intervals by start time first", "Merge if current interval overlaps with previous", "Update end time to max of both ends"], "starterCode": [{"language": "python", "code": "def merge(intervals):\n    # Your code here\n    pass"}, {"language": "javascript", "code": "function merge(intervals) {\n    // Your code here\n}"}], "testCases": [{"input": "[[1,3], [2,6], [8,10], [15,18]]", "expectedOutput": "[[1,6], [8,10], [15,18]]", "isHidden": false}, {"input": "[[1,4], [4,5]]", "expectedOutput": "[[1,5]]", "isHidden": false}], "solution": [{"language": "python", "code": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    for interval in intervals:\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return merged"}]}


