{"_id": "lesson-intro-to-arrays", "_type": "lesson", "title": "Introduction to Arrays", "slug": {"_type": "slug", "current": "intro-to-arrays"}, "order": 1, "type": "concept", "xpReward": 50, "estimatedMinutes": 10, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "What is an Array?"}]}, {"_type": "block", "_key": "b2", "children": [{"_type": "span", "text": "An array is a collection of elements stored at contiguous memory locations. It's the most fundamental data structure in computer science and forms the building block for many other data structures."}]}, {"_type": "block", "_key": "b3", "style": "h3", "children": [{"_type": "span", "text": "Key Characteristics"}]}, {"_type": "block", "_key": "b4", "children": [{"_type": "span", "text": "• Fixed size (in most languages) or dynamic size\n• Elements are accessed by index (0-based)\n• Contiguous memory allocation\n• O(1) access time by index\n• O(n) insertion/deletion in middle"}]}, {"_type": "block", "_key": "b5", "style": "h3", "children": [{"_type": "span", "text": "When to Use Arrays"}]}, {"_type": "block", "_key": "b6", "children": [{"_type": "span", "text": "Use arrays when you need fast access by index, know the size in advance, or need to store a sequence of similar elements. They're perfect for implementing other data structures like stacks, queues, and hash tables."}]}]}
{"_id": "lesson-array-operations", "_type": "lesson", "title": "Array Operations", "slug": {"_type": "slug", "current": "array-operations"}, "order": 2, "type": "concept", "xpReward": 50, "estimatedMinutes": 15, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "Common Array Operations"}]}, {"_type": "block", "_key": "b2", "children": [{"_type": "span", "text": "Understanding the time complexity of array operations is crucial for writing efficient code."}]}, {"_type": "block", "_key": "b3", "style": "h3", "children": [{"_type": "span", "text": "Access - O(1)"}]}, {"_type": "block", "_key": "b4", "children": [{"_type": "span", "text": "Accessing any element by index takes constant time because arrays use contiguous memory. The address is calculated as: base_address + (index × element_size)"}]}, {"_type": "block", "_key": "b5", "style": "h3", "children": [{"_type": "span", "text": "Search - O(n)"}]}, {"_type": "block", "_key": "b6", "children": [{"_type": "span", "text": "Linear search requires checking each element. For sorted arrays, binary search achieves O(log n)."}]}, {"_type": "block", "_key": "b7", "style": "h3", "children": [{"_type": "span", "text": "Insert/Delete - O(n)"}]}, {"_type": "block", "_key": "b8", "children": [{"_type": "span", "text": "Inserting or deleting requires shifting elements. Appending to the end is O(1) amortized for dynamic arrays."}]}, {"_type": "block", "_key": "b9", "style": "h3", "children": [{"_type": "span", "text": "Two-Pointer Technique"}]}, {"_type": "block", "_key": "b10", "children": [{"_type": "span", "text": "A powerful pattern where you use two indices to traverse the array. Useful for: finding pairs, reversing arrays, removing duplicates, and partitioning."}]}]}
{"_id": "lesson-intro-to-linked-lists", "_type": "lesson", "title": "Introduction to Linked Lists", "slug": {"_type": "slug", "current": "intro-to-linked-lists"}, "order": 1, "type": "concept", "xpReward": 50, "estimatedMinutes": 15, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "What is a Linked List?"}]}, {"_type": "block", "_key": "b2", "children": [{"_type": "span", "text": "A linked list is a linear data structure where elements are stored in nodes. Each node contains data and a reference (pointer) to the next node in the sequence."}]}, {"_type": "block", "_key": "b3", "style": "h3", "children": [{"_type": "span", "text": "Types of Linked Lists"}]}, {"_type": "block", "_key": "b4", "children": [{"_type": "span", "text": "• Singly Linked List: Each node points to the next node\n• Doubly Linked List: Nodes point to both next and previous\n• Circular Linked List: Last node points back to first"}]}, {"_type": "block", "_key": "b5", "style": "h3", "children": [{"_type": "span", "text": "Arrays vs Linked Lists"}]}, {"_type": "block", "_key": "b6", "children": [{"_type": "span", "text": "Linked lists excel at insertions/deletions (O(1) if you have the node reference) but have O(n) access time. Arrays have O(1) access but O(n) insertions. Choose based on your use case!"}]}, {"_type": "block", "_key": "b7", "style": "h3", "children": [{"_type": "span", "text": "Node Structure"}]}, {"_type": "block", "_key": "b8", "children": [{"_type": "span", "text": "A typical node has two parts: the data it stores and a pointer to the next node. In Python: class Node: def __init__(self, val): self.val = val; self.next = None"}]}]}
{"_id": "lesson-linked-list-operations", "_type": "lesson", "title": "Linked List Operations", "slug": {"_type": "slug", "current": "linked-list-operations"}, "order": 2, "type": "concept", "xpReward": 50, "estimatedMinutes": 15, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "Essential Linked List Operations"}]}, {"_type": "block", "_key": "b2", "style": "h3", "children": [{"_type": "span", "text": "Traversal"}]}, {"_type": "block", "_key": "b3", "children": [{"_type": "span", "text": "Start from the head and follow the next pointers until you reach null. Time: O(n), Space: O(1)."}]}, {"_type": "block", "_key": "b4", "style": "h3", "children": [{"_type": "span", "text": "Insertion"}]}, {"_type": "block", "_key": "b5", "children": [{"_type": "span", "text": "• At head: O(1) - Create new node, point it to current head, update head\n• At tail: O(n) or O(1) with tail pointer\n• At position: O(n) - Traverse to position, update pointers"}]}, {"_type": "block", "_key": "b6", "style": "h3", "children": [{"_type": "span", "text": "Deletion"}]}, {"_type": "block", "_key": "b7", "children": [{"_type": "span", "text": "Update the previous node's next pointer to skip the deleted node. Don't forget to handle edge cases: deleting head, deleting tail, empty list."}]}, {"_type": "block", "_key": "b8", "style": "h3", "children": [{"_type": "span", "text": "Common Patterns"}]}, {"_type": "block", "_key": "b9", "children": [{"_type": "span", "text": "• Fast & Slow pointers (Floyd's algorithm)\n• Dummy head node to simplify edge cases\n• Recursion for elegant solutions\n• Reversing in-place with three pointers"}]}]}
{"_id": "lesson-intro-to-stacks", "_type": "lesson", "title": "Introduction to Stacks", "slug": {"_type": "slug", "current": "intro-to-stacks"}, "order": 1, "type": "concept", "xpReward": 50, "estimatedMinutes": 10, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "What is a Stack?"}]}, {"_type": "block", "_key": "b2", "children": [{"_type": "span", "text": "A stack is a Last-In-First-Out (LIFO) data structure. Think of a stack of plates - you can only add or remove from the top."}]}, {"_type": "block", "_key": "b3", "style": "h3", "children": [{"_type": "span", "text": "Core Operations"}]}, {"_type": "block", "_key": "b4", "children": [{"_type": "span", "text": "• push(item): Add item to top - O(1)\n• pop(): Remove and return top item - O(1)\n• peek()/top(): View top item without removing - O(1)\n• isEmpty(): Check if stack is empty - O(1)"}]}, {"_type": "block", "_key": "b5", "style": "h3", "children": [{"_type": "span", "text": "Real-World Applications"}]}, {"_type": "block", "_key": "b6", "children": [{"_type": "span", "text": "• Undo/Redo functionality in editors\n• Browser back button history\n• Function call stack in programming\n• Expression evaluation and parsing\n• Backtracking algorithms"}]}, {"_type": "block", "_key": "b7", "style": "h3", "children": [{"_type": "span", "text": "Implementation"}]}, {"_type": "block", "_key": "b8", "children": [{"_type": "span", "text": "Stacks can be implemented using arrays or linked lists. In Python, use a list with append() and pop(). In JavaScript, use an array with push() and pop()."}]}]}
{"_id": "lesson-stack-operations", "_type": "lesson", "title": "Stack Operations & Use Cases", "slug": {"_type": "slug", "current": "stack-operations"}, "order": 2, "type": "concept", "xpReward": 50, "estimatedMinutes": 15, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "Stack Problem Patterns"}]}, {"_type": "block", "_key": "b2", "style": "h3", "children": [{"_type": "span", "text": "Matching Parentheses"}]}, {"_type": "block", "_key": "b3", "children": [{"_type": "span", "text": "The classic stack problem! Push opening brackets, pop and match when you see closing brackets. Stack should be empty at the end for a valid expression."}]}, {"_type": "block", "_key": "b4", "style": "h3", "children": [{"_type": "span", "text": "Monotonic Stack"}]}, {"_type": "block", "_key": "b5", "children": [{"_type": "span", "text": "A stack that maintains elements in sorted order (increasing or decreasing). Useful for: Next Greater Element, Stock Span Problem, Largest Rectangle in Histogram."}]}, {"_type": "block", "_key": "b6", "style": "h3", "children": [{"_type": "span", "text": "Expression Evaluation"}]}, {"_type": "block", "_key": "b7", "children": [{"_type": "span", "text": "Use two stacks: one for operands and one for operators. Handle operator precedence by comparing with stack top before pushing."}]}, {"_type": "block", "_key": "b8", "style": "h3", "children": [{"_type": "span", "text": "Tips for Stack Problems"}]}, {"_type": "block", "_key": "b9", "children": [{"_type": "span", "text": "• When you see 'matching' or 'nested' - think stack\n• When you need the 'previous' or 'next' greater/smaller element - monotonic stack\n• When order matters and you process in reverse - stack helps"}]}]}
{"_id": "lesson-intro-to-trees", "_type": "lesson", "title": "Introduction to Trees", "slug": {"_type": "slug", "current": "intro-to-trees"}, "order": 1, "type": "concept", "xpReward": 60, "estimatedMinutes": 20, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "What is a Tree?"}]}, {"_type": "block", "_key": "b2", "children": [{"_type": "span", "text": "A tree is a hierarchical data structure consisting of nodes connected by edges. It has a root node at the top, and every node (except the root) has exactly one parent."}]}, {"_type": "block", "_key": "b3", "style": "h3", "children": [{"_type": "span", "text": "Tree Terminology"}]}, {"_type": "block", "_key": "b4", "children": [{"_type": "span", "text": "• Root: Top node with no parent\n• Leaf: Node with no children\n• Height: Longest path from root to leaf\n• Depth: Distance from root to a node\n• Subtree: A node and all its descendants"}]}, {"_type": "block", "_key": "b5", "style": "h3", "children": [{"_type": "span", "text": "Binary Trees"}]}, {"_type": "block", "_key": "b6", "children": [{"_type": "span", "text": "Each node has at most 2 children (left and right). Special types: Full (every node has 0 or 2 children), Complete (all levels filled except possibly last), Perfect (all internal nodes have 2 children, all leaves at same level)."}]}, {"_type": "block", "_key": "b7", "style": "h3", "children": [{"_type": "span", "text": "Binary Search Trees (BST)"}]}, {"_type": "block", "_key": "b8", "children": [{"_type": "span", "text": "A binary tree where: left subtree contains only nodes less than the parent, right subtree contains only nodes greater. Enables O(log n) search, insert, delete in balanced trees."}]}]}
{"_id": "lesson-tree-traversals", "_type": "lesson", "title": "Tree Traversals", "slug": {"_type": "slug", "current": "tree-traversals"}, "order": 2, "type": "concept", "xpReward": 60, "estimatedMinutes": 20, "content": [{"_type": "block", "_key": "b1", "style": "h2", "children": [{"_type": "span", "text": "Tree Traversal Methods"}]}, {"_type": "block", "_key": "b2", "children": [{"_type": "span", "text": "Traversing a tree means visiting every node exactly once. There are two main approaches: Depth-First Search (DFS) and Breadth-First Search (BFS)."}]}, {"_type": "block", "_key": "b3", "style": "h3", "children": [{"_type": "span", "text": "DFS Traversals"}]}, {"_type": "block", "_key": "b4", "children": [{"_type": "span", "text": "• Inorder (Left, Root, Right): Gives sorted order for BST\n• Preorder (Root, Left, Right): Used to copy/serialize a tree\n• Postorder (Left, Right, Root): Used to delete a tree"}]}, {"_type": "block", "_key": "b5", "style": "h3", "children": [{"_type": "span", "text": "BFS / Level Order"}]}, {"_type": "block", "_key": "b6", "children": [{"_type": "span", "text": "Visit nodes level by level, from left to right. Uses a queue. Perfect for finding shortest path, level averages, or rightmost nodes."}]}, {"_type": "block", "_key": "b7", "style": "h3", "children": [{"_type": "span", "text": "Recursive vs Iterative"}]}, {"_type": "block", "_key": "b8", "children": [{"_type": "span", "text": "DFS is naturally recursive (uses call stack). For iterative DFS, use an explicit stack. BFS is naturally iterative with a queue. Know both approaches!"}]}, {"_type": "block", "_key": "b9", "style": "h3", "children": [{"_type": "span", "text": "Time & Space Complexity"}]}, {"_type": "block", "_key": "b10", "children": [{"_type": "span", "text": "All traversals: O(n) time. Space: O(h) for DFS (h = height), O(w) for BFS (w = max width). For balanced trees, h = log(n)."}]}]}


